include("PeriodicOrbit.jl")
using .PeriodicOrbit
using NbodyGradient
using Statistics
using Random
using PyPlot


struct TTVData
    planet_id::Int
    transit_numbers::Vector{Int}
    transit_times::Vector{Float64}
    linear_predictions::Vector{Float64}
    ttv_observations::Vector{Float64}
    ttv_uncertainties::Vector{Float64}
end

function load_ttv_data(filename::String)
    """Load TTV data from file generated by forward model"""
    data = []
    open(filename, "r") do file
        for line in eachline(file)
            if startswith(line, "#") || isempty(strip(line))
                continue
            end
            parts = split(strip(line))
            push!(data, (parse(Int, parts[1]), parse(Float64, parts[2]), 
                        parse(Float64, parts[3]), parse(Float64, parts[4])))
        end
    end
    
    if isempty(data)
        error("No data found in file: $filename")
    end
    
    planet_id = contains(filename, "planet1") ? 1 : 2
    
    transit_numbers = [d[1] for d in data]
    transit_times = [d[2] for d in data]
    linear_predictions = [d[3] for d in data]
    ttv_observations = [d[4] for d in data]
    ttv_uncertainties = fill(1.0, length(ttv_observations))  # 1-minute uncertainties
    
    return TTVData(planet_id, transit_numbers, transit_times, 
                   linear_predictions, ttv_observations, ttv_uncertainties)
end

struct MCMCParameters
    log_mass1::Float64
    log_mass2::Float64
    period1::Float64
    period_ratio::Float64
    e1::Float64
    e2::Float64
    mean_anomaly1::Float64
    mean_anomaly2::Float64
    omega_diff::Float64
    kappa::Float64
    tsys::Float64
end

function mcmc_to_optvec(params::MCMCParameters)
    """Convert MCMC parameters to optimization vector format"""
    mass1 = 10^params.log_mass1
    mass2 = 10^params.log_mass2
    
    optvec = [
        params.e1, params.e2,
        params.mean_anomaly1, params.mean_anomaly2,
        params.omega_diff,
        params.period1,
        mass1, mass2,
        params.kappa,
        0.0,
        params.tsys
    ]
    
    return optvec
end

function compute_model_ttvs(params::MCMCParameters, observed_data::TTVData)
    """Forward model: compute predicted TTVs for given parameters"""
    try
        optvec = mcmc_to_optvec(params)
        optparams = OptimParameters(2, optvec)
        orbparams = OrbitParameters(2, [0.5])
        
        orbit = Orbit(2, optparams, orbparams)
        elems = get_orbital_elements(orbit.s, orbit.ic)
        
        # Set up edge-on system for transit detection
        star_edgeon = Elements(m=1.0)
        planet1_edgeon = Elements(m=elems[2].m, P=elems[2].P, e=0.01, ω=0.0, I=π/2, Ω=0.0, t0=0.0)
        planet2_edgeon = Elements(m=elems[3].m, P=elems[3].P, e=0.01, ω=π, I=π/2, Ω=0.0, t0=0.0)
        
        el_ic_edgeon = ElementsIC(0.0, 3, star_edgeon, planet1_edgeon, planet2_edgeon)
        
        P_inner = elems[2].P
        h_int = P_inner / 100.0
        tmax = P_inner * 30
        
        state_nbody = State(el_ic_edgeon)
        tt_nbody = TransitTiming(tmax, el_ic_edgeon)
        Integrator(ahl21!, h_int, tmax)(state_nbody, tt_nbody)
        
        planet_idx = observed_data.planet_id
        if tt_nbody.count[planet_idx] < 3
            return nothing
        end
        
        transit_times = tt_nbody.tt[planet_idx, 1:tt_nbody.count[planet_idx]]
        
        n_idx = 0:(length(transit_times)-1)
        P_fit = (transit_times[end] - transit_times[1]) / (length(transit_times) - 1)
        t0_fit = transit_times[1]
        linear_prediction = t0_fit .+ P_fit .* n_idx
        model_ttvs = (transit_times .- linear_prediction) .* 24 * 60
        
        return model_ttvs
        
    catch e
        return nothing
    end
end

function interpolate_model_ttvs(model_ttvs::Vector{Float64}, observed_data::TTVData)
    """Match model TTVs to observed transit count"""
    if length(model_ttvs) < length(observed_data.ttv_observations)
        return fill(1e6, length(observed_data.ttv_observations))
    end
    
    n_obs = length(observed_data.ttv_observations)
    return model_ttvs[1:n_obs]
end

function log_likelihood(params::MCMCParameters, observed_data::TTVData)
    model_ttvs = compute_model_ttvs(params, observed_data)
    
    if model_ttvs === nothing
        return -Inf
    end
    
    interp_ttvs = interpolate_model_ttvs(model_ttvs, observed_data)
    
    chi_squared = sum(((observed_data.ttv_observations .- interp_ttvs) ./ observed_data.ttv_uncertainties).^2)
    
    return -0.5 * chi_squared
end

function log_prior(params::MCMCParameters)
    if params.log_mass1 < -5 || params.log_mass1 > -1; return -Inf; end
    if params.log_mass2 < -5 || params.log_mass2 > -1; return -Inf; end
    if params.period1 < 300 || params.period1 > 400; return -Inf; end
    if params.period_ratio < 2.0 || params.period_ratio > 3.0; return -Inf; end
    if params.e1 < 0 || params.e1 > 0.1; return -Inf; end
    if params.e2 < 0 || params.e2 > 0.1; return -Inf; end
    if abs(params.mean_anomaly1) > π; return -Inf; end
    if abs(params.mean_anomaly2) > π; return -Inf; end
    if abs(params.omega_diff) > π; return -Inf; end
    if params.kappa < 2.0 || params.kappa > 3.0; return -Inf; end
    if params.tsys < 500 || params.tsys > 700; return -Inf; end
    
    return 0.0
end

function propose_step(current_params::MCMCParameters, step_sizes::Dict)
    return MCMCParameters(
        current_params.log_mass1 + randn() * step_sizes[:log_mass1],
        current_params.log_mass2 + randn() * step_sizes[:log_mass2],
        current_params.period1 + randn() * step_sizes[:period1],
        current_params.period_ratio + randn() * step_sizes[:period_ratio],
        current_params.e1 + randn() * step_sizes[:e1],
        current_params.e2 + randn() * step_sizes[:e2],
        current_params.mean_anomaly1 + randn() * step_sizes[:mean_anomaly1],
        current_params.mean_anomaly2 + randn() * step_sizes[:mean_anomaly2],
        current_params.omega_diff + randn() * step_sizes[:omega_diff],
        current_params.kappa + randn() * step_sizes[:kappa],
        current_params.tsys + randn() * step_sizes[:tsys]
    )
end

function run_ttv_mcmc(observed_data::TTVData; n_iterations::Int=3000, n_burn::Int=1000)
    current_params = MCMCParameters(
        log10(0.000952) + 0.001 * randn(),   # log_mass1
        log10(0.000286) + 0.001 * randn(),   # log_mass2
        363.2 + 0.1 * randn(),               # period1
        2.48 + 0.001 * randn(),              # period_ratio
        0.0008 + 0.00001 * randn(),          # e1
        0.0018 + 0.00001 * randn(),          # e2
        0.001 * randn(),                     # mean_anomaly1
        0.001 * randn(),                     # mean_anomaly2
        π + 0.001 * randn(),                 # omega_diff
        2.487 + 0.001 * randn(),             # kappa
        605.3 + 0.1 * randn()                # tsys
    )
    
    step_sizes = Dict(
        :log_mass1 => 0.001, :log_mass2 => 0.001,
        :period1 => 0.1, :period_ratio => 0.001,
        :e1 => 0.000001, :e2 => 0.000001,
        :mean_anomaly1 => 0.001, :mean_anomaly2 => 0.001, :omega_diff => 0.001,
        :kappa => 0.001, :tsys => 0.1
    )
    
  
    chain = []
    log_likelihoods = []
    
    current_log_likelihood = log_likelihood(current_params, observed_data)
    current_log_prior = log_prior(current_params)
    current_log_posterior = current_log_likelihood + current_log_prior
    
    println("Initial log-likelihood: $(round(current_log_likelihood, digits=2))")
    
    n_accepted = 0
    
    for i in 1:n_iterations
        proposed_params = propose_step(current_params, step_sizes)
        
        proposed_log_prior = log_prior(proposed_params)
        if proposed_log_prior == -Inf
            push!(chain, current_params)
            push!(log_likelihoods, current_log_likelihood)
            continue
        end
        
        proposed_log_likelihood = log_likelihood(proposed_params, observed_data)
        proposed_log_posterior = proposed_log_likelihood + proposed_log_prior
        
        log_alpha = proposed_log_posterior - current_log_posterior
        
        if log(rand()) < log_alpha
            current_params = proposed_params
            current_log_likelihood = proposed_log_likelihood
            current_log_posterior = proposed_log_posterior
            n_accepted += 1
        end
        
        push!(chain, current_params)
        push!(log_likelihoods, current_log_likelihood)
        
        if i % 500 == 0
            acceptance_rate = n_accepted / i * 100
            println("Iteration $i: LL = $(round(current_log_likelihood, digits=1)), Accept = $(round(acceptance_rate, digits=1))%")
        end
    end
    
    final_acceptance = n_accepted / n_iterations * 100
    println("Acceptance rate: $(round(final_acceptance, digits=1))%")
    
    return chain, log_likelihoods, n_burn
end

function analyze_results(chain, log_likelihoods, n_burn, observed_data)
    post_burn_chain = chain[(n_burn+1):end]
    post_burn_likelihoods = log_likelihoods[(n_burn+1):end]
    
    best_idx = argmax(post_burn_likelihoods)
    best_params = post_burn_chain[best_idx]
    
    # Compute uncertainties
    mass1_samples = [10^p.log_mass1 for p in post_burn_chain]
    mass2_samples = [10^p.log_mass2 for p in post_burn_chain]
    period1_samples = [p.period1 for p in post_burn_chain]
    ratio_samples = [p.period_ratio for p in post_burn_chain]
    e1_samples = [p.e1 for p in post_burn_chain]
    e2_samples = [p.e2 for p in post_burn_chain]
    kappa_samples = [p.kappa for p in post_burn_chain]
    
    println("Recovered Parameters (± 1σ uncertainties):")
    println("  Mass 1: $(round(10^best_params.log_mass1, digits=6)) ± $(round(std(mass1_samples), digits=1)) M_sun")
    println("  Mass 2: $(round(10^best_params.log_mass2, digits=6)) ± $(round(std(mass2_samples), digits=1)) M_sun")
    println("  Period 1: $(round(best_params.period1, digits=2)) ± $(round(std(period1_samples), digits=2)) days")
    println("  Period ratio: $(round(best_params.period_ratio, digits=3)) ± $(round(std(ratio_samples), digits=3))")
    println("  Eccentricity 1: $(round(best_params.e1, digits=6)) ± $(round(std(e1_samples), digits=1))")
    println("  Eccentricity 2: $(round(best_params.e2, digits=6)) ± $(round(std(e2_samples), digits=1))")
    println("  Kappa: $(round(best_params.kappa, digits=4)) ± $(round(std(kappa_samples), digits=4))")
    
    # Model fit quality
    best_model_ttvs = compute_model_ttvs(best_params, observed_data)
    if best_model_ttvs !== nothing
        interp_ttvs = interpolate_model_ttvs(best_model_ttvs, observed_data)
        residuals = observed_data.ttv_observations .- interp_ttvs
        rms_residual = sqrt(mean(residuals.^2))
        
        println("\nModel Fit Quality:")
        println("  RMS residual: $(round(rms_residual, digits=2)) minutes")
        println("  Chi-squared: $(round(sum((residuals ./ observed_data.ttv_uncertainties).^2), digits=2))")
        
        # Create comparison plot
        figure(figsize=(12, 8))
        
        subplot(2, 1, 1)
        plot(observed_data.transit_numbers, observed_data.ttv_observations, "o", 
             label="Observed TTVs", markersize=8, color="blue")
        plot(observed_data.transit_numbers, interp_ttvs, "s", 
             label="Best-fit model", markersize=6, color="red")
        xlabel("Transit number")
        ylabel("TTV (minutes)")
        title("TTV Recovery Results: Planet $(observed_data.planet_id)")
        legend()
        grid(true, alpha=0.3)
        
        subplot(2, 1, 2)
        plot(observed_data.transit_numbers, residuals, "o-", color="green")
        xlabel("Transit number")
        ylabel("Residuals (minutes)")
        title("Fit Residuals (RMS = $(round(rms_residual, digits=2)) min)")
        grid(true, alpha=0.3)
        axhline(y=0, color="black", linestyle="--", alpha=0.5)
        
        tight_layout()
        savefig("ttv_recovery_results.png", dpi=300, bbox_inches="tight")
        println("Saved results plot: ttv_recovery_results.png")
    end
    
    return best_params
end

function save_results(best_params, observed_data)
    """Save recovered parameters to file"""
    filename = "recovered_parameters_planet$(observed_data.planet_id).txt"
    open(filename, "w") do file
        println(file, "# TTV-recovered planetary parameters")
        println(file, "# Planet $(observed_data.planet_id)")
        println(file, "log_mass1 $(best_params.log_mass1)")
        println(file, "log_mass2 $(best_params.log_mass2)")
        println(file, "period1 $(best_params.period1)")
        println(file, "period_ratio $(best_params.period_ratio)")
        println(file, "e1 $(best_params.e1)")
        println(file, "e2 $(best_params.e2)")
        println(file, "kappa $(best_params.kappa)")
        println(file, "tsys $(best_params.tsys)")
    end
    println("Saved results: $filename")
end

function main()
   
    # Load TTV observations
    ttv_filename = "bestfit_orbit_planet2_ttvs.txt"
 
    observed_data = load_ttv_data(ttv_filename)
    
    # Run MCMC
    chain, log_likelihoods, n_burn = run_ttv_mcmc(observed_data, n_iterations=5000, n_burn=1500)

    best_params = analyze_results(chain, log_likelihoods, n_burn, observed_data)
    save_results(best_params, observed_data)
    
end

main()